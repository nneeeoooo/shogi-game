<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Â∞ÜÊ£ã„Ç≤„Éº„É†</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        
        /* „É°„Éã„É•„Éº */
        .menu {
            text-align: center;
            padding: 40px;
        }
        
        .menu.hidden { display: none; }
        
        .mode-select {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 30px 0;
        }
        
        .mode-btn {
            padding: 20px 30px;
            background: white;
            color: #667eea;
            border: 3px solid #667eea;
            border-radius: 15px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .mode-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-3px);
        }
        
        .mode-btn.selected {
            background: #667eea;
            color: white;
        }
        
        .difficulty-select {
            margin: 20px 0;
            display: none;
        }
        
        .difficulty-select.show { display: block; }
        
        .diff-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }
        
        .diff-btn {
            padding: 10px 20px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .diff-btn:hover {
            background: #e0e0e0;
            border-color: #667eea;
        }
        
        .diff-btn.selected {
            background: #764ba2;
            color: white;
            border-color: #764ba2;
        }
        
        .start-btn {
            padding: 15px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .start-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* „Ç≤„Éº„É†ÁîªÈù¢ */
        .game {
            display: none;
        }
        
        .game.active { display: block; }
        
        .info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
        }
        
        .turn-display {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
        }
        
        .captured-area {
            display: flex;
            gap: 20px;
        }
        
        .captured-section h3 {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .captured-list {
            display: flex;
            gap: 3px;
            min-height: 30px;
        }
        
        .captured-piece {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            border-radius: 3px;
        }
        
        .captured-piece:hover { background: #e0e0e0; }
        .captured-piece.selected { background: #ffeb3b; }
        
        .board {
            display: grid;
            grid-template-columns: repeat(9, 60px);
            gap: 1px;
            background: #8B4513;
            padding: 10px;
            margin: 0 auto;
            width: fit-content;
        }
        
        .cell {
            width: 60px;
            height: 60px;
            background: #F5DEB3;
            border: 1px solid #8B4513;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }
        
        .cell:hover { background: #E5CDA3; }
        .cell.selected { background: #FFD700; box-shadow: inset 0 0 0 3px #FFA500; }
        .cell.possible { background: #90EE90; }
        .cell.capture { background: #FFB6C1; }
        .cell.last-move { background: #B0E0E6; }
        
        .piece {
            font-size: 24px;
            font-weight: bold;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            user-select: none;
        }
        
        .piece.sente {
            background: white;
            color: #333;
            border: 2px solid #333;
        }
        
        .piece.gote {
            background: #333;
            color: white;
            border: 2px solid white;
            transform: rotate(180deg);
        }
        
        .piece.promoted.sente {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #D00;
            border: 2px solid #FF6347;
        }
        
        .piece.promoted.gote {
            background: linear-gradient(135deg, #8B4513, #A0522D);
            color: #FFD700;
            border: 2px solid #FFD700;
            transform: rotate(180deg);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        
        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #5567d8;
            transform: translateY(-2px);
        }
        
        /* Èü≥Ê•Ω„Ç≥„É≥„Éà„É≠„Éº„É´ */
        .music-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            cursor: pointer;
            font-size: 24px;
            transition: all 0.3s;
            z-index: 100;
        }
        
        .music-control:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }
        
        .message {
            text-align: center;
            margin-top: 15px;
            font-size: 16px;
            min-height: 24px;
        }
        
        .message.error { color: #f44336; font-weight: bold; }
        .message.success { color: #4CAF50; font-weight: bold; }
        .message.info { color: #2196F3; }
        
        /* ÂãùÂà©„É¢„Éº„ÉÄ„É´ */
        .victory-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .victory-modal.show { display: flex; }
        
        .victory-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            animation: bounce 0.5s;
        }
        
        @keyframes bounce {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .victory-title {
            font-size: 32px;
            color: #FFD700;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .victory-msg {
            font-size: 20px;
            color: #333;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <!-- BGM audio element -->
    <audio id="bgm" loop>
        <source src="bgm.mp3" type="audio/mpeg">
        <source src="bgm.ogg" type="audio/ogg">
        Your browser does not support the audio element.
    </audio>
    <!-- Èü≥Ê•Ω„Ç≥„É≥„Éà„É≠„Éº„É´„Éú„Çø„É≥ -->
    <div class="music-control" onclick="toggleMusic()" title="Èü≥Ê•Ω„ÅÆÂÜçÁîü/ÂÅúÊ≠¢">
        <span id="musicIcon">üéµ</span>
    </div>
    
    <div class="container">
        <h1>üéØ Â∞ÜÊ£ã„Ç≤„Éº„É† üéØ</h1>
        
        <!-- „É°„Éã„É•„Éº -->
        <div id="menu" class="menu">
            <div style="font-size: 20px; color: #667eea; margin-bottom: 20px;">ÂØæÊà¶„É¢„Éº„ÉâÈÅ∏Êäû</div>
            <div class="mode-select">
                <button class="mode-btn" onclick="selectMode('pvp')">üë• ‰∫∫Èñì vs ‰∫∫Èñì</button>
                <button class="mode-btn" onclick="selectMode('ai')">ü§ñ ‰∫∫Èñì vs AI</button>
            </div>
            <div id="diffSelect" class="difficulty-select">
                <div>AI„ÅÆÂº∑„Åï</div>
                <div class="diff-buttons">
                    <button class="diff-btn" onclick="selectDiff('easy')">ÂàùÁ¥ö</button>
                    <button class="diff-btn selected" onclick="selectDiff('normal')">‰∏≠Á¥ö</button>
                    <button class="diff-btn" onclick="selectDiff('hard')">‰∏äÁ¥ö</button>
                </div>
            </div>
            <button id="startBtn" class="start-btn" onclick="startGame()" disabled>„Ç≤„Éº„É†ÈñãÂßã</button>
        </div>
        
        <!-- „Ç≤„Éº„É† -->
        <div id="game" class="game">
            <div class="info-bar">
                <div class="turn-display">ÁèæÂú®: <span id="turnText">ÂÖàÊâã</span></div>
                <div class="captured-area">
                    <div class="captured-section">
                        <h3>ÂÖàÊâã„ÅÆÊåÅÈßí</h3>
                        <div id="senteCap" class="captured-list"></div>
                    </div>
                    <div class="captured-section">
                        <h3>ÂæåÊâã„ÅÆÊåÅÈßí</h3>
                        <div id="goteCap" class="captured-list"></div>
                    </div>
                </div>
            </div>
            
            <div id="board" class="board"></div>
            
            <div class="controls">
                <button onclick="backToMenu()">„É°„Éã„É•„Éº</button>
                <button onclick="newGame()">Êñ∞Ë¶è„Ç≤„Éº„É†</button>
                <button onclick="undo()">Êàª„Åô</button>
            </div>
            
            <div id="msg" class="message"></div>
        </div>
        
        <!-- ÂãùÂà©„É¢„Éº„ÉÄ„É´ -->
        <div id="victoryModal" class="victory-modal">
            <div class="victory-content">
                <div class="victory-title">üèÜ „Ç≤„Éº„É†ÁµÇ‰∫Ü üèÜ</div>
                <div id="victoryMsg" class="victory-msg"></div>
                <div class="controls">
                    <button onclick="newGame(); closeVictory()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
                    <button onclick="backToMenu(); closeVictory()">„É°„Éã„É•„Éº</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // === ÂÆöÊï∞ÂÆöÁæ© ===
        const PIECES = {
            KING: 'Áéã', ROOK: 'È£õ', BISHOP: 'Ëßí', GOLD: 'Èáë',
            SILVER: 'ÈäÄ', KNIGHT: 'Ê°Ç', LANCE: 'È¶ô', PAWN: 'Ê≠©',
            DRAGON: 'Èæç', HORSE: 'È¶¨', PROMOTED_SILVER: 'ÂÖ®',
            PROMOTED_KNIGHT: 'Âú≠', PROMOTED_LANCE: 'Êùè', TOKIN: '„Å®'
        };
        
        // === „Ç≤„Éº„É†Áä∂ÊÖã ===
        let board = [];
        let turn = 'sente';
        let selected = null;
        let possibleMoves = [];
        let captured = { sente: [], gote: [] };
        let history = [];
        let lastMove = null;
        let mode = null;
        let difficulty = 'normal';
        let gameEnded = false;
        let musicPlaying = false;
        
        // === ÂàùÊúüÂåñ ===
        function initBoard() {
            board = Array(9).fill(null).map(() => Array(9).fill(null));
            
            // ÈÖçÁΩÆ„Éá„Éº„Çø
            const setup = {
                gote: [
                    [[0,0,'È¶ô'],[0,1,'Ê°Ç'],[0,2,'ÈäÄ'],[0,3,'Èáë'],[0,4,'Áéã'],[0,5,'Èáë'],[0,6,'ÈäÄ'],[0,7,'Ê°Ç'],[0,8,'È¶ô']],
                    [[1,1,'Ëßí'],[1,7,'È£õ']],
                    Array.from({length:9}, (_,i) => [2,i,'Ê≠©'])
                ],
                sente: [
                    [[8,0,'È¶ô'],[8,1,'Ê°Ç'],[8,2,'ÈäÄ'],[8,3,'Èáë'],[8,4,'Áéã'],[8,5,'Èáë'],[8,6,'ÈäÄ'],[8,7,'Ê°Ç'],[8,8,'È¶ô']],
                    [[7,7,'Ëßí'],[7,1,'È£õ']],
                    Array.from({length:9}, (_,i) => [6,i,'Ê≠©'])
                ]
            };
            
            Object.entries(setup).forEach(([owner, rows]) => {
                rows.flat().forEach(([r, c, type]) => {
                    board[r][c] = { type, owner };
                });
            });
        }
        
        // === ÁßªÂãïË®àÁÆó ===
        function getMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            
            const moves = [];
            const dir = piece.owner === 'sente' ? -1 : 1;
            
            // ÁßªÂãï„Éë„Çø„Éº„É≥ÂÆöÁæ©
            const patterns = {
                'Ê≠©': [[dir, 0]],
                'Ê°Ç': [[dir*2, -1], [dir*2, 1]],
                'ÈäÄ': [[dir,-1],[dir,0],[dir,1],[-dir,-1],[-dir,1]],
                'Èáë': [[dir,-1],[dir,0],[dir,1],[0,-1],[0,1],[-dir,0]],
                '„Å®': [[dir,-1],[dir,0],[dir,1],[0,-1],[0,1],[-dir,0]],
                'ÂÖ®': [[dir,-1],[dir,0],[dir,1],[0,-1],[0,1],[-dir,0]],
                'Âú≠': [[dir,-1],[dir,0],[dir,1],[0,-1],[0,1],[-dir,0]],
                'Êùè': [[dir,-1],[dir,0],[dir,1],[0,-1],[0,1],[-dir,0]],
                'Áéã': [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
            };
            
            // È£õËªä„ÉªËßíË°åÁ≥ª„ÅÆÁßªÂãï
            if (['È£õ','Èæç'].includes(piece.type)) {
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc]) => {
                    for (let i = 1; i < 9; i++) {
                        const nr = row + dr*i, nc = col + dc*i;
                        if (!inBounds(nr, nc)) break;
                        if (!board[nr][nc] || board[nr][nc].owner !== piece.owner) {
                            moves.push([nr, nc]);
                            if (board[nr][nc]) break;
                        } else break;
                    }
                });
                if (piece.type === 'Èæç') {
                    [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr,dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (inBounds(nr, nc) && (!board[nr][nc] || board[nr][nc].owner !== piece.owner)) {
                            moves.push([nr, nc]);
                        }
                    });
                }
            }
            
            if (['Ëßí','È¶¨'].includes(piece.type)) {
                [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr,dc]) => {
                    for (let i = 1; i < 9; i++) {
                        const nr = row + dr*i, nc = col + dc*i;
                        if (!inBounds(nr, nc)) break;
                        if (!board[nr][nc] || board[nr][nc].owner !== piece.owner) {
                            moves.push([nr, nc]);
                            if (board[nr][nc]) break;
                        } else break;
                    }
                });
                if (piece.type === 'È¶¨') {
                    [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (inBounds(nr, nc) && (!board[nr][nc] || board[nr][nc].owner !== piece.owner)) {
                            moves.push([nr, nc]);
                        }
                    });
                }
            }
            
            // È¶ôËªä„ÅÆÁâπÂà•Âá¶ÁêÜÔºàÈßí„ÇíÈ£õ„Å≥Ë∂ä„Åà„Çâ„Çå„Å™„ÅÑÔºâ
            if (piece.type === 'È¶ô') {
                for (let i = 1; i < 9; i++) {
                    const nr = row + dir * i, nc = col;
                    if (!inBounds(nr, nc)) break;
                    if (!board[nr][nc]) {
                        moves.push([nr, nc]);
                    } else {
                        if (board[nr][nc].owner !== piece.owner) {
                            moves.push([nr, nc]);  // Êïµ„ÅÆÈßí„ÅØÂèñ„Çå„Çã
                        }
                        break;  // Èßí„Åå„ÅÇ„Å£„Åü„Çâ„ÄÅ„Åù„Çå‰ª•‰∏äÈÄ≤„ÇÅ„Å™„ÅÑ
                    }
                }
            }
            
            // ÈÄöÂ∏∏„Éë„Çø„Éº„É≥
            const pattern = patterns[piece.type];
            if (pattern) {
                pattern.forEach(([dr, dc]) => {
                    const nr = row + dr, nc = col + dc;
                    if (inBounds(nr, nc) && (!board[nr][nc] || board[nr][nc].owner !== piece.owner)) {
                        moves.push([nr, nc]);
                    }
                });
            }
            
            return moves;
        }
        
        // === ÊåÅÈßíÈÖçÁΩÆ ===
        function getDrops(piece, owner) {
            const drops = [];
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c]) continue;
                    
                    // ‰∫åÊ≠©
                    if (piece === 'Ê≠©') {
                        if (board.some(row => row[c]?.type === 'Ê≠©' && row[c]?.owner === owner)) continue;
                        if ((owner === 'sente' && r === 0) || (owner === 'gote' && r === 8)) continue;
                    }
                    
                    // Ë°å„ÅçÊâÄ„ÅÆ„Å™„ÅÑÈßí
                    if (piece === 'È¶ô' && ((owner === 'sente' && r === 0) || (owner === 'gote' && r === 8))) continue;
                    if (piece === 'Ê°Ç' && ((owner === 'sente' && r <= 1) || (owner === 'gote' && r >= 7))) continue;
                    
                    drops.push([r, c]);
                }
            }
            return drops;
        }
        
        // === Êàê„ÇäÂá¶ÁêÜ ===
        function canPromote(piece, fromRow, toRow) {
            const promotable = ['Ê≠©','È¶ô','Ê°Ç','ÈäÄ','Ëßí','È£õ'];
            if (!promotable.includes(piece.type)) return false;
            
            return piece.owner === 'sente' 
                ? (fromRow <= 2 || toRow <= 2)
                : (fromRow >= 6 || toRow >= 6);
        }
        
        function mustPromote(piece, toRow) {
            if (piece.owner === 'sente') {
                if (['Ê≠©','È¶ô'].includes(piece.type) && toRow === 0) return true;
                if (piece.type === 'Ê°Ç' && toRow <= 1) return true;
            } else {
                if (['Ê≠©','È¶ô'].includes(piece.type) && toRow === 8) return true;
                if (piece.type === 'Ê°Ç' && toRow >= 7) return true;
            }
            return false;
        }
        
        function promote(piece) {
            const map = {
                'Ê≠©':'„Å®', 'È¶ô':'Êùè', 'Ê°Ç':'Âú≠', 'ÈäÄ':'ÂÖ®', 'Ëßí':'È¶¨', 'È£õ':'Èæç'
            };
            if (map[piece.type]) piece.type = map[piece.type];
        }
        
        function demote(piece) {
            const map = {
                '„Å®':'Ê≠©', 'Êùè':'È¶ô', 'Âú≠':'Ê°Ç', 'ÂÖ®':'ÈäÄ', 'È¶¨':'Ëßí', 'Èæç':'È£õ'
            };
            if (map[piece.type]) piece.type = map[piece.type];
            return piece;
        }
        
        // === ÁßªÂãïÂÆüË°åÔºàÁéãÂ∞ÜÊçïÁç≤Âà§ÂÆöÂº∑ÂåñÔºâ ===
        function executeMove(from, to, isAi = false) {
            if (gameEnded) return;
            
            const piece = board[from[0]][from[1]];
            const target = board[to[0]][to[1]];
            
            // ‚òÖ‚òÖ‚òÖ ÁéãÂ∞ÜÊçïÁç≤„ÉÅ„Çß„ÉÉ„ÇØÔºàÊúÄÈáçË¶ÅÔºâ ‚òÖ‚òÖ‚òÖ
            if (target && target.type === 'Áéã') {
                console.log(`ÁéãÂ∞ÜÊçïÁç≤ÔºÅ ${piece.owner}„ÅÆÂãùÂà©`);
                endGame(piece.owner);
                return;
            }
            
            // Â±•Ê≠¥‰øùÂ≠ò
            history.push({
                from, to,
                piece: JSON.parse(JSON.stringify(piece)),
                captured: target ? JSON.parse(JSON.stringify(target)) : null,
                promoted: false
            });
            
            // ÈßíÂèñ„Çä
            if (target) {
                const demoted = demote(JSON.parse(JSON.stringify(target)));
                demoted.owner = piece.owner;
                captured[piece.owner].push(demoted);
            }
            
            // ÁßªÂãï
            board[to[0]][to[1]] = piece;
            board[from[0]][from[1]] = null;
            
            // Êàê„Çä
            if (canPromote(piece, from[0], to[0])) {
                let shouldPromote = mustPromote(piece, to[0]);
                if (!shouldPromote) {
                    shouldPromote = isAi 
                        ? Math.random() < 0.7
                        : confirm(`${piece.type}„ÇíÊàê„Çä„Åæ„Åô„ÅãÔºü`);
                }
                if (shouldPromote) {
                    promote(piece);
                    history[history.length-1].promoted = true;
                }
            }
            
            lastMove = { from, to };
            turn = turn === 'sente' ? 'gote' : 'sente';
            updateUI();
            
            // AI
            if (mode === 'ai' && turn === 'gote' && !gameEnded) {
                setTimeout(aiMove, 500);
            }
        }
        
        function drop(pieceIdx, pos) {
            if (gameEnded) return;
            
            const piece = captured[turn][pieceIdx];
            
            history.push({
                drop: true,
                to: pos,
                piece: JSON.parse(JSON.stringify(piece)),
                index: pieceIdx
            });
            
            board[pos[0]][pos[1]] = piece;
            captured[turn].splice(pieceIdx, 1);
            
            lastMove = { drop: true, to: pos };
            turn = turn === 'sente' ? 'gote' : 'sente';
            updateUI();
            
            if (mode === 'ai' && turn === 'gote' && !gameEnded) {
                setTimeout(aiMove, 500);
            }
        }
        
        // === „Ç≤„Éº„É†ÁµÇ‰∫ÜÔºàÁ¢∫ÂÆü„Å™ÂÆüË£ÖÔºâ ===
        function endGame(winner) {
            gameEnded = true;
            const msg = mode === 'ai' 
                ? (winner === 'sente' ? '„ÅÇ„Å™„Åü„ÅÆÂãùÂà©ÔºÅ' : 'AI„ÅÆÂãùÂà©ÔºÅ')
                : `${winner === 'sente' ? 'ÂÖàÊâã' : 'ÂæåÊâã'}„ÅÆÂãùÂà©ÔºÅ`;
            
            document.getElementById('victoryMsg').textContent = msg;
            document.getElementById('victoryModal').classList.add('show');
            console.log('„Ç≤„Éº„É†ÁµÇ‰∫Ü:', msg);
        }
        
        function closeVictory() {
            document.getElementById('victoryModal').classList.remove('show');
        }
        
        // === AIË©ï‰æ°„Ç∑„Çπ„ÉÜ„É† ===
        const PIECE_VALUES = {
            'Ê≠©': 100, 'È¶ô': 350, 'Ê°Ç': 400, 'ÈäÄ': 550, 'Èáë': 600,
            'Ëßí': 900, 'È£õ': 1000, 'Áéã': 50000,
            '„Å®': 650, 'Êùè': 550, 'Âú≠': 550, 'ÂÖ®': 600,
            'È¶¨': 1100, 'Èæç': 1300
        };
        
        // ‰ΩçÁΩÆË©ï‰æ°„ÉÜ„Éº„Éñ„É´Ôºà‰∏≠Â§Æ„ÇÑÊïµÈô£„Å´Ëøë„ÅÑ„Åª„Å©È´òË©ï‰æ°Ôºâ
        function getPositionScore(piece, row, col, owner) {
            if (owner === 'gote') {
                // ÂæåÊâã„ÅÆÂ†¥Âêà„ÄÅÊïµÈô£Ôºà‰∏ãÂÅ¥Ôºâ„Å´Ëøë„ÅÑ„Åª„Å©È´òË©ï‰æ°
                if (['Ê≠©', 'È¶ô', 'Ê°Ç', 'ÈäÄ'].includes(piece.type)) {
                    return (8 - row) * 10;  // ÂâçÈÄ≤„Éú„Éº„Éä„Çπ
                }
                if (piece.type === 'È£õ') {
                    return col === 1 ? 20 : 0;  // È£õËªä„ÅØ2Á≠ã„ÅåÁêÜÊÉ≥
                }
                if (piece.type === 'Ëßí') {
                    return Math.min(row, col, 8-row, 8-col) * 5;  // ‰∏≠Â§Æ„Éú„Éº„Éä„Çπ
                }
            }
            return 0;
        }
        
        // Áõ§Èù¢Ë©ï‰æ°Èñ¢Êï∞
        function evaluateBoard() {
            let score = 0;
            
            // Èßí„ÅÆ‰æ°ÂÄ§Ë®àÁÆó
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = board[r][c];
                    if (piece) {
                        const value = PIECE_VALUES[piece.type] + getPositionScore(piece, r, c, piece.owner);
                        score += piece.owner === 'gote' ? value : -value;
                    }
                }
            }
            
            // ÊåÅÈßí„ÅÆ‰æ°ÂÄ§
            Object.entries(captured).forEach(([owner, pieces]) => {
                pieces.forEach(piece => {
                    const value = PIECE_VALUES[piece.type] * 0.9;  // ÊåÅÈßí„ÅØÂ∞ë„Åó‰æ°ÂÄ§„Çí‰∏ã„Åí„Çã
                    score += owner === 'gote' ? value : -value;
                });
            });
            
            // Áéã„ÅÆÂÆâÂÖ®ÊÄßË©ï‰æ°
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c]?.type === 'Áéã') {
                        const owner = board[r][c].owner;
                        // Áéã„ÅÆÂë®„Çä„Å´Âë≥Êñπ„ÅÆÈßí„Åå„ÅÇ„Çã„Åã
                        let defenders = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r + dr, nc = c + dc;
                                if (inBounds(nr, nc) && board[nr][nc]?.owner === owner) {
                                    defenders++;
                                }
                            }
                        }
                        score += (owner === 'gote' ? defenders : -defenders) * 50;
                    }
                }
            }
            
            return score;
        }
        
        // Minimax„Ç¢„É´„Ç¥„É™„Ç∫„É†Ôºà„Ç¢„É´„Éï„Ç°„Éô„Éº„ÇøÊûùÂàà„Çä‰ªò„ÅçÔºâ
        function minimax(depth, alpha, beta, maximizing) {
            if (depth === 0) {
                return evaluateBoard();
            }
            
            const moves = getAllMoves(maximizing ? 'gote' : 'sente');
            
            if (maximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    // ‰ªÆÊÉ≥ÁöÑ„Å´Êâã„ÇíÂÆüË°å
                    const backup = makeVirtualMove(move);
                    const eval = minimax(depth - 1, alpha, beta, false);
                    undoVirtualMove(move, backup);
                    
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;  // ÊûùÂàà„Çä
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const backup = makeVirtualMove(move);
                    const eval = minimax(depth - 1, alpha, beta, true);
                    undoVirtualMove(move, backup);
                    
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;  // ÊûùÂàà„Çä
                }
                return minEval;
            }
        }
        
        // ‰ªÆÊÉ≥ÁöÑ„Å™Êâã„ÅÆÂÆüË°å
        function makeVirtualMove(move) {
            if (move.drop) {
                const piece = captured[turn][move.index];
                const backup = { piece: JSON.parse(JSON.stringify(piece)), index: move.index };
                board[move.to[0]][move.to[1]] = piece;
                captured[turn].splice(move.index, 1);
                turn = turn === 'sente' ? 'gote' : 'sente';
                return backup;
            } else {
                const piece = board[move.from[0]][move.from[1]];
                const target = board[move.to[0]][move.to[1]];
                const backup = {
                    piece: JSON.parse(JSON.stringify(piece)),
                    target: target ? JSON.parse(JSON.stringify(target)) : null
                };
                
                if (target) {
                    const demoted = demote(JSON.parse(JSON.stringify(target)));
                    demoted.owner = piece.owner;
                    captured[piece.owner].push(demoted);
                }
                
                board[move.to[0]][move.to[1]] = piece;
                board[move.from[0]][move.from[1]] = null;
                
                // Êàê„ÇäÂà§ÂÆöÔºàAI„ÅØ70%„ÅÆÁ¢∫Áéá„ÅßÊàê„ÇãÔºâ
                if (canPromote(piece, move.from[0], move.to[0]) && Math.random() < 0.7) {
                    promote(piece);
                    backup.promoted = true;
                }
                
                turn = turn === 'sente' ? 'gote' : 'sente';
                return backup;
            }
        }
        
        // ‰ªÆÊÉ≥ÁöÑ„Å™Êâã„ÇíÊàª„Åô
        function undoVirtualMove(move, backup) {
            turn = turn === 'sente' ? 'gote' : 'sente';
            
            if (move.drop) {
                board[move.to[0]][move.to[1]] = null;
                captured[turn].splice(backup.index, 0, backup.piece);
            } else {
                const piece = board[move.to[0]][move.to[1]];
                if (backup.promoted) demote(piece);
                board[move.from[0]][move.from[1]] = piece;
                board[move.to[0]][move.to[1]] = backup.target;
                if (backup.target) {
                    captured[piece.owner].pop();
                }
            }
        }
        
        // === „É°„Ç§„É≥AIÈñ¢Êï∞ ===
        function aiMove() {
            const moves = getAllMoves('gote');
            if (moves.length === 0) return;
            
            // Áéã„ÇíÂèñ„Çå„ÇãÊâã„ÇíÊúÄÂÑ™ÂÖà
            const kingCapture = moves.find(m => {
                if (m.drop) return false;
                const target = board[m.to[0]][m.to[1]];
                return target && target.type === 'Áéã';
            });
            
            if (kingCapture) {
                console.log('AI„ÅåÁéã„ÇíÊçïÁç≤ÔºÅ');
                executeMove(kingCapture.from, kingCapture.to, true);
                return;
            }
            
            let selectedMove;
            
            if (difficulty === 'easy') {
                // ÂàùÁ¥öÔºö„É©„É≥„ÉÄ„É†„Å´Êâã„ÇíÈÅ∏„Å∂„Åå„ÄÅÊòé„Çâ„Åã„Å´ËâØ„ÅÑÊâãÔºàÈßíÂæóÔºâ„ÅØÂÑ™ÂÖà
                const captureMoves = moves.filter(m => !m.drop && board[m.to[0]][m.to[1]]);
                if (captureMoves.length > 0 && Math.random() < 0.7) {
                    selectedMove = captureMoves[Math.floor(Math.random() * captureMoves.length)];
                } else {
                    selectedMove = moves[Math.floor(Math.random() * moves.length)];
                }
            } else if (difficulty === 'normal') {
                // ‰∏≠Á¥öÔºöÊ∑±„Åï2„ÅÆMinimax
                let bestScore = -Infinity;
                let bestMoves = [];
                
                for (const move of moves) {
                    const backup = makeVirtualMove(move);
                    const score = minimax(2, -Infinity, Infinity, false);
                    undoVirtualMove(move, backup);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [move];
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                }
                
                // Âêå„ÅòË©ï‰æ°„ÅÆÊâã„Åã„Çâ„É©„É≥„ÉÄ„É†„Å´ÈÅ∏Êäû
                selectedMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
            } else {
                // ‰∏äÁ¥öÔºöÊ∑±„Åï3„ÅÆMinimax„Å®„Ç¢„É´„Éï„Ç°„Éô„Éº„ÇøÊûùÂàà„Çä
                let bestScore = -Infinity;
                let bestMoves = [];
                
                // Êâã„Çí‰∫ãÂâçË©ï‰æ°„Åó„Å¶„ÇΩ„Éº„ÉàÔºàÊûùÂàà„ÇäÂäπÁéáÂêë‰∏äÔºâ
                moves.sort((a, b) => {
                    let scoreA = 0, scoreB = 0;
                    if (!a.drop) {
                        const targetA = board[a.to[0]][a.to[1]];
                        if (targetA) scoreA = PIECE_VALUES[targetA.type];
                    }
                    if (!b.drop) {
                        const targetB = board[b.to[0]][b.to[1]];
                        if (targetB) scoreB = PIECE_VALUES[targetB.type];
                    }
                    return scoreB - scoreA;
                });
                
                for (const move of moves) {
                    const backup = makeVirtualMove(move);
                    const score = minimax(3, -Infinity, Infinity, false);
                    undoVirtualMove(move, backup);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [move];
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                }
                
                selectedMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
            }
            
            // Êâã„ÇíÂÆüË°å
            if (selectedMove.drop) {
                drop(selectedMove.index, selectedMove.to);
            } else {
                executeMove(selectedMove.from, selectedMove.to, true);
            }
        }
        
        function getAllMoves(owner) {
            const moves = [];
            
            // Áõ§‰∏ä„ÅÆÈßí
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c]?.owner === owner) {
                        getMoves(r, c).forEach(to => {
                            moves.push({ from: [r, c], to });
                        });
                    }
                }
            }
            
            // ÊåÅÈßí
            captured[owner].forEach((piece, idx) => {
                getDrops(piece.type, owner).forEach(to => {
                    moves.push({ drop: true, to, index: idx });
                });
            });
            
            return moves;
        }
        
        // === UI ===
        function renderBoard() {
            const el = document.getElementById('board');
            el.innerHTML = '';
            
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    // „Éè„Ç§„É©„Ç§„Éà
                    if (lastMove) {
                        if ((lastMove.from && lastMove.from[0] === r && lastMove.from[1] === c) ||
                            (lastMove.to[0] === r && lastMove.to[1] === c)) {
                            cell.classList.add('last-move');
                        }
                    }
                    
                    if (selected && !selected.type && selected[0] === r && selected[1] === c) {
                        cell.classList.add('selected');
                    }
                    
                    if (possibleMoves.some(m => m[0] === r && m[1] === c)) {
                        cell.classList.add(board[r][c] ? 'capture' : 'possible');
                    }
                    
                    // Èßí
                    const piece = board[r][c];
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `piece ${piece.owner}`;
                        pieceEl.textContent = piece.type;
                        
                        // Êàê„ÇäÈßí„ÅÆÂà§ÂÆö„Å®ÈÅ©Âàá„Å™„ÇØ„É©„Çπ‰ªò‰∏é
                        const promotedPieces = ['Èæç','È¶¨','„Å®','ÂÖ®','Âú≠','Êùè'];
                        if (promotedPieces.includes(piece.type)) {
                            pieceEl.classList.add('promoted');
                            // ÊâÄÊúâËÄÖ„Å´Âøú„Åò„Å¶„ÇØ„É©„Çπ„ÇíËøΩÂä†ÔºàCSS„ÅßË¶ã„ÅüÁõÆ„ÇíÂà∂Âæ°Ôºâ
                        }
                        
                        cell.appendChild(pieceEl);
                    }
                    
                    cell.onclick = () => clickCell(r, c);
                    el.appendChild(cell);
                }
            }
        }
        
        function updateCaptured() {
            ['sente', 'gote'].forEach(owner => {
                const el = document.getElementById(owner === 'sente' ? 'senteCap' : 'goteCap');
                el.innerHTML = '';
                captured[owner].forEach((piece, idx) => {
                    const div = document.createElement('div');
                    div.className = 'captured-piece';
                    div.textContent = piece.type;
                    div.onclick = () => selectCaptured(owner, idx);
                    el.appendChild(div);
                });
            });
        }
        
        function updateUI() {
            renderBoard();
            updateCaptured();
            document.getElementById('turnText').textContent = 
                mode === 'ai' ? (turn === 'sente' ? '„ÅÇ„Å™„Åü' : 'AI') : 
                (turn === 'sente' ? 'ÂÖàÊâã' : 'ÂæåÊâã');
        }
        
        function showMsg(text, type = '') {
            const el = document.getElementById('msg');
            el.textContent = text;
            el.className = 'message ' + type;
            if (text) setTimeout(() => el.textContent = '', 3000);
        }
        
        // === ÂÖ•ÂäõÂá¶ÁêÜ ===
        function clickCell(r, c) {
            if (gameEnded || (mode === 'ai' && turn === 'gote')) return;
            
            const piece = board[r][c];
            
            if (selected) {
                if (selected.type === 'captured') {
                    // ÊåÅÈßíÈÖçÁΩÆ
                    if (possibleMoves.some(m => m[0] === r && m[1] === c)) {
                        drop(selected.index, [r, c]);
                        clearSelection();
                        renderBoard();
                    } else {
                        clearSelection();
                        renderBoard();
                    }
                } else {
                    // ÈßíÁßªÂãï
                    if (possibleMoves.some(m => m[0] === r && m[1] === c)) {
                        executeMove(selected, [r, c]);
                        clearSelection();
                    } else if (piece?.owner === turn) {
                        clearSelection();
                        selected = [r, c];
                        possibleMoves = getMoves(r, c);
                        renderBoard();
                    } else {
                        clearSelection();
                        renderBoard();
                    }
                }
            } else if (piece?.owner === turn) {
                selected = [r, c];
                possibleMoves = getMoves(r, c);
                renderBoard();
            }
        }
        
        function selectCaptured(owner, idx) {
            if (gameEnded || owner !== turn || (mode === 'ai' && turn === 'gote')) return;
            
            clearSelection();
            selected = { type: 'captured', index: idx, owner: owner };
            possibleMoves = getDrops(captured[owner][idx].type, owner);
            
            // ÊåÅÈßí„Çí„Éè„Ç§„É©„Ç§„ÉàË°®Á§∫
            document.querySelectorAll('.captured-piece').forEach(el => {
                el.classList.remove('selected');
            });
            const capArea = document.getElementById(owner === 'sente' ? 'senteCap' : 'goteCap');
            if (capArea.children[idx]) {
                capArea.children[idx].classList.add('selected');
            }
            
            renderBoard();
        }
        
        function clearSelection() {
            selected = null;
            possibleMoves = [];
            
            // ÊåÅÈßí„ÅÆÈÅ∏ÊäûÁä∂ÊÖã„Çí„ÇØ„É™„Ç¢
            document.querySelectorAll('.captured-piece').forEach(el => {
                el.classList.remove('selected');
            });
        }
        
        // === „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ ===
        function inBounds(r, c) {
            return r >= 0 && r < 9 && c >= 0 && c < 9;
        }
        
        function undo() {
            if (gameEnded || history.length === 0) return;
            
            const count = (mode === 'ai' && turn === 'sente') ? 2 : 1;
            
            for (let i = 0; i < count && history.length > 0; i++) {
                const move = history.pop();
                
                if (move.drop) {
                    board[move.to[0]][move.to[1]] = null;
                    captured[move.piece.owner].splice(move.index, 0, move.piece);
                } else {
                    const piece = board[move.to[0]][move.to[1]];
                    if (move.promoted) demote(piece);
                    board[move.from[0]][move.from[1]] = piece;
                    board[move.to[0]][move.to[1]] = move.captured;
                    if (move.captured) captured[piece.owner].pop();
                }
                
                turn = turn === 'sente' ? 'gote' : 'sente';
            }
            
            lastMove = history.length > 0 ? 
                (history[history.length-1].drop ? 
                    { drop: true, to: history[history.length-1].to } :
                    { from: history[history.length-1].from, to: history[history.length-1].to }) : null;
            
            updateUI();
            showMsg('Êàª„Åó„Åæ„Åó„Åü', 'info');
        }
        
        // === „É°„Éã„É•„Éº ===
        function selectMode(m) {
            mode = m;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('selected'));
            event.target.classList.add('selected');
            document.getElementById('diffSelect').classList.toggle('show', m === 'ai');
            document.getElementById('startBtn').disabled = false;
        }
        
        function selectDiff(d) {
            difficulty = d;
            document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
            event.target.classList.add('selected');
        }
        
        function startGame() {
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('game').classList.add('active');
            init();
        }
        
        function backToMenu() {
            if (!gameEnded && history.length > 0 && !confirm('„É°„Éã„É•„Éº„Å´Êàª„Çä„Åæ„Åô„ÅãÔºü')) return;
            
            document.getElementById('game').classList.remove('active');
            document.getElementById('menu').classList.remove('hidden');
            mode = null;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('selected'));
            document.getElementById('diffSelect').classList.remove('show');
            document.getElementById('startBtn').disabled = true;
        }
        
        function newGame() {
            if (!gameEnded && history.length > 0 && !confirm('Êñ∞„Åó„ÅÑ„Ç≤„Éº„É†„ÇíÈñãÂßã„Åó„Åæ„Åô„ÅãÔºü')) return;
            init();
            showMsg('Êñ∞Ë¶è„Ç≤„Éº„É†ÈñãÂßã', 'success');
        }
        
        function init() {
            turn = 'sente';
            selected = null;
            possibleMoves = [];
            captured = { sente: [], gote: [] };
            history = [];
            lastMove = null;
            gameEnded = false;
            
            initBoard();
            updateUI();
            showMsg('');
        }
        
        // === Èü≥Ê•Ω„Ç≥„É≥„Éà„É≠„Éº„É´ ===
        function toggleMusic() {
            const audio = document.getElementById('bgm');
            const icon = document.getElementById('musicIcon');
            
            if (musicPlaying) {
                audio.pause();
                icon.textContent = 'üîá';
                musicPlaying = false;
            } else {
                audio.play().catch(err => {
                    console.log('Èü≥Ê•Ω„ÅÆÂÜçÁîü„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', err);
                    showMsg('Èü≥Ê•Ω„Éï„Ç°„Ç§„É´(bgm.mp3)„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                });
                icon.textContent = 'üéµ';
                musicPlaying = true;
            }
        }
        
        // Èü≥ÈáèË™øÊï¥Ôºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
        window.onload = function() {
            const audio = document.getElementById('bgm');
            audio.volume = 0.3; // Èü≥Èáè„Çí30%„Å´Ë®≠ÂÆöÔºà0.0ÔΩû1.0Ôºâ
        };
    </script>
</body>
</html>